= type

Describes a kind of value.

To style your document, you need to work with values of different kinds: Lengths specifying the size of your elements, colors for your text and shapes, and more. Typst categorizes these into clearly defined _types_ and tells you where it expects which type of value.

Apart from basic types for numeric values and #link("/docs/reference/foundations/int/")[typical] #link("/docs/reference/foundations/float/")[types] #link("/docs/reference/foundations/str/")[known] #link("/docs/reference/foundations/array/")[from] #link("/docs/reference/foundations/dictionary/")[programming] languages, Typst provides a special type for #link("/docs/reference/foundations/content/")[content.] A value of this type can hold anything that you can enter into your document: Text, elements like headings and shapes, and style information.

== Example

```typst
#let x = 10
#if type(x) == int [
  #x is an integer!
] else [
  #x is another value...
]

An image is of type
#type(image("glacier.jpg")).
```

The type of `10` is `int`. Now, what is the type of `int` or even `type`?

```typst
#type(int) \
#type(type)
```

== Compatibility

In Typst 0.7 and lower, the `type` function returned a string instead of a type. Compatibility with the old way will remain until Typst 0.14 to give package authors time to upgrade.

- Checks like `int == "integer"` evaluate to `true`
- Adding/joining a type and string will yield a string
- The `in` operator on a type and a dictionary will evaluate to `true` if the dictionary has a string key matching the type's name

== Constructor

Determines a value's type.

```
type(
  any
) -> type
```

```typst
#type(12) \
#type(14.7) \
#type("hello") \
#type(<glacier>) \
#type([Hi]) \
#type(x => x + 1) \
#type(type)
```

==== `value`: any (Required, Positional)

The value whose type's to determine.
= version

A version with an arbitrary number of components.

The first three components have names that can be used as fields: `major`, `minor`, `patch`. All following components do not have names.

The list of components is semantically extended by an infinite list of zeros. This means that, for example, `0.8` is the same as `0.8.0`. As a special case, the empty version (that has no components at all) is the same as `0`, `0.0`, `0.0.0`, and so on.

The current version of the Typst compiler is available as `sys.version`.

You can convert a version to an array of explicitly given components using the #link("/docs/reference/foundations/array/")[array] constructor.

== Constructor

Creates a new version.

It can have any number of components (even zero).

```
version(
  ..: int | array
) -> version
```

```typst
#version() \
#version(1) \
#version(1, 2, 3, 4) \
#version((1, 2, 3, 4)) \
#version((1, 2), 3)
```

==== `components`: int | array (Required, Positional, Variadic)

The components of the version (array arguments are flattened)

== Definitions

=== `at`

Retrieves a component of a version.

The returned integer is always non-negative. Returns `0` if the version isn't specified to the necessary length.

```
at(
  int: int
) -> int
```

==== `index`: int (Required, Positional)

The index at which to retrieve the component. If negative, indexes from the back of the explicitly given components.
= elem

An HTML element that can contain Typst content.

Typst's HTML export automatically generates the appropriate tags for most elements. However, sometimes, it is desirable to retain more control. For example, when using Typst to generate your blog, you could use this function to wrap each article in an `<article>` tag.

Typst is aware of what is valid HTML. A tag and its attributes must form syntactically valid HTML. Some tags, like `meta` do not accept content. Hence, you must not provide a body for them. We may add more checks in the future, so be sure that you are generating valid HTML when using this function.

Normally, Typst will generate `html`, `head`, and `body` tags for you. If you instead create them with this function, Typst will omit its own tags.

== Parameters

```
elem(
  str: str,
  attrs: dictionary,
  body: none | content
) -> content
```

=== `tag`: str (Required, Positional)

The element's tag.

=== `attrs`: dictionary (Settable)

The element's HTML attributes.

Default: `(:)`

=== `body`: none | content (Positional, Settable)

The contents of the HTML element.

The body can be arbitrary Typst content.

Default: `none`
= frame

An element that lays out its content as an inline SVG.

Sometimes, converting Typst content to HTML is not desirable. This can be the case for plots and other content that relies on positioning and styling to convey its message.

This function allows you to use the Typst layout engine that would also be used for PDF, SVG, and PNG export to render a part of your document exactly how it would appear when exported in one of these formats. It embeds the content as an inline SVG.

== Parameters

```
frame(
  content: content
) -> content
```

=== `body`: content (Required, Positional)

The content that shall be laid out.
= counter

Counts through pages, elements, and more.

With the counter function, you can access and modify counters for pages, headings, figures, and more. Moreover, you can define custom counters for other things you want to count.

Since counters change throughout the course of the document, their current value is _contextual._ It is recommended to read the chapter on #link("/docs/reference/context/")[context] before continuing here.

== Accessing a counter

To access the raw value of a counter, we can use the #link("/docs/reference/introspection/counter/#definitions-get")[get] function. This function returns an #link("/docs/reference/foundations/array/")[array]: Counters can have multiple levels (in the case of headings for sections, subsections, and so on), and each item in the array corresponds to one level.

```typst
#set heading(numbering: "1.")

= Introduction
Raw value of heading counter is
#context counter(heading).get()
```

== Displaying a counter

Often, we want to display the value of a counter in a more human-readable way. To do that, we can call the #link("/docs/reference/introspection/counter/#definitions-display")[display] function on the counter. This function retrieves the current counter value and formats it either with a provided or with an automatically inferred #link("/docs/reference/model/numbering/")[numbering].

```typst
#set heading(numbering: "1.")

= Introduction
Some text here.

= Background
The current value is: #context {
  counter(heading).display()
}

Or in roman numerals: #context {
  counter(heading).display("I")
}
```

== Modifying a counter

To modify a counter, you can use the `step` and `update` methods:

- The step method increases the value of the counter by one. Because counters can have multiple levels , it optionally takes a level argument. If given, the counter steps at the given depth.
- The update method allows you to arbitrarily modify the counter. In its basic form, you give it an integer (or an array for multiple levels). For more flexibility, you can instead also give it a function that receives the current value and returns a new value.

The heading counter is stepped before the heading is displayed, so `Analysis` gets the number seven even though the counter is at six after the second update.

```typst
#set heading(numbering: "1.")

= Introduction
#counter(heading).step()

= Background
#counter(heading).update(3)
#counter(heading).update(n => n * 2)

= Analysis
Let's skip 7.1.
#counter(heading).step(level: 2)

== Analysis
Still at #context {
  counter(heading).display()
}
```

== Page counter

The page counter is special. It is automatically stepped at each pagebreak. But like other counters, you can also step it manually. For example, you could have Roman page numbers for your preface, then switch to Arabic page numbers for your main content and reset the page counter to one.

```typst
#set page(numbering: "(i)")

= Preface
The preface is numbered with
roman numerals.

#set page(numbering: "1 / 1")
#counter(page).update(1)

= Main text
Here, the counter is reset to one.
We also display both the current
page and total number of pages in
Arabic numbers.
```

== Custom counters

To define your own counter, call the `counter` function with a string as a key. This key identifies the counter globally.

```typst
#let mine = counter("mycounter")
#context mine.display() \
#mine.step()
#context mine.display() \
#mine.update(c => c * 3)
#context mine.display()
```

== How to step

When you define and use a custom counter, in general, you should first step the counter and then display it. This way, the stepping behaviour of a counter can depend on the element it is stepped for. If you were writing a counter for, let's say, theorems, your theorem's definition would thus first include the counter step and only then display the counter and the theorem's contents.

```typst
#let c = counter("theorem")
#let theorem(it) = block[
  #c.step()
  *Theorem #context c.display():*
  #it
]

#theorem[$1 = 1$]
#theorem[$2 < 3$]
```

The rationale behind this is best explained on the example of the heading counter: An update to the heading counter depends on the heading's level. By stepping directly before the heading, we can correctly step from `1` to `1.1` when encountering a level 2 heading. If we were to step after the heading, we wouldn't know what to step to.

Because counters should always be stepped before the elements they count, they always start at zero. This way, they are at one for the first display (which happens after the first step).

== Time travel

Counters can travel through time! You can find out the final value of the counter before it is reached and even determine what the value was at any particular location in the document.

```typst
#let mine = counter("mycounter")

= Values
#context [
  Value here: #mine.get() \
  At intro: #mine.at(<intro>) \
  Final value: #mine.final()
]

#mine.update(n => n + 3)

= Introduction <intro>
#lorem(10)

#mine.step()
#mine.step()
```

== Other kinds of state

The `counter` type is closely related to #link("/docs/reference/introspection/state/")[state] type. Read its documentation for more details on state management in Typst and why it doesn't just use normal variables for counters.

== Constructor

Create a new counter identified by a key.

```
counter(
  str: str | label | selector | location | function
) -> counter
```

==== `key`: str | label | selector | location | function (Required, Positional)

The key that identifies this counter.

- If it is a string, creates a custom counter that is only affected by manual updates,
- If it is the #link("/docs/reference/layout/page/")[page] function, counts through pages,
- If it is a #link("/docs/reference/foundations/selector/")[selector], counts through elements that matches with the selector. For example, provide an element function: counts elements of that type, provide a <label>: counts elements with that label.

== Definitions

=== `get`

Retrieves the value of the counter at the current location. Always returns an array of integers, even if the counter has just one number.

This is equivalent to `counter.at(here())`.

```
get(
  
) -> array
```

=== `display`

Displays the current value of the counter with a numbering and returns the formatted output.

```
display(
  auto: auto | str | function,
  both: bool
) -> bool
```

==== `numbering`: auto | str | function (Positional)

A #link("/docs/reference/model/numbering/")[numbering pattern or a function], which specifies how to display the counter. If given a function, that function receives each number of the counter as a separate argument. If the amount of numbers varies, e.g. for the heading argument, you can use an #link("/docs/reference/foundations/arguments/")[argument sink].

If this is omitted or set to `auto`, displays the counter with the numbering style for the counted element or with the pattern `"1.1"` if no such style exists.

Default: `auto`

==== `both`: bool

If enabled, displays the current and final top-level count together. Both can be styled through a single numbering pattern. This is used by the page numbering property to display the current and total number of pages when a pattern like `"1 / 1"` is given.

Default: `false`

=== `at`

Retrieves the value of the counter at the given location. Always returns an array of integers, even if the counter has just one number.

The `selector` must match exactly one element in the document. The most useful kinds of selectors for this are #link("/docs/reference/foundations/label/")[labels] and #link("/docs/reference/introspection/location/")[locations].

```
at(
  label: label | selector | location | function
) -> array
```

==== `selector`: label | selector | location | function (Required, Positional)

The place at which the counter's value should be retrieved.

=== `final`

Retrieves the value of the counter at the end of the document. Always returns an array of integers, even if the counter has just one number.

```
final(
  
) -> array
```

=== `step`

Increases the value of the counter by one.

The update will be in effect at the position where the returned content is inserted into the document. If you don't put the output into the document, nothing happens! This would be the case, for example, if you write `let _ = counter(page).step()`. Counter updates are always applied in layout order and in that case, Typst wouldn't know when to step the counter.

```
step(
  level: int
) -> content
```

==== `level`: int

The depth at which to step the counter. Defaults to `1`.

Default: `1`

=== `update`

Updates the value of the counter.

Just like with `step`, the update only occurs if you put the resulting content into the document.

```
update(
  int: int | array | function
) -> content
```

==== `update`: int | array | function (Required, Positional)

If given an integer or array of integers, sets the counter to that value. If given a function, that function receives the previous counter value (with each number as a separate argument) and has to return the new value (integer or array).
= here

Provides the current location in the document.

You can think of `here` as a low-level building block that directly extracts the current location from the active #link("/docs/reference/context/")[context]. Some other functions use it internally: For instance, `counter.get()` is equivalent to `counter.at(here())`.

Within show rules on #link("/docs/reference/introspection/location/#locatable")[locatable] elements, `here()` will match the location of the shown element.

If you want to display the current page number, refer to the documentation of the #link("/docs/reference/introspection/counter/")[counter] type. While `here` can be used to determine the physical page number, typically you want the logical page number that may, for instance, have been reset after a preface.

== Examples

Determining the current position in the document in combination with the #link("/docs/reference/introspection/location/#definitions-position")[position] method:

```typst
#context [
  I am located at
  #here().position()
]
```

Running a #link("/docs/reference/introspection/query/")[query] for elements before the current position:

```typst
= Introduction
= Background

There are
#context query(
  selector(heading).before(here())
).len()
headings before me.

= Conclusion
```

Refer to the #link("/docs/reference/foundations/selector/")[selector] type for more details on before/after selectors.

== Parameters

```
here(
  
) -> location
```
= locate

Determines the location of an element in the document.

Takes a selector that must match exactly one element and returns that element's #link("/docs/reference/introspection/location/")[location]. This location can, in particular, be used to retrieve the physical #link("/docs/reference/introspection/location/#definitions-page")[page] number and #link("/docs/reference/introspection/location/#definitions-position")[position] (page, x, y) for that element.

== Examples

Locating a specific element:

```typst
#context [
  Introduction is at: \
  #locate(<intro>).position()
]

= Introduction <intro>
```

== Parameters

```
locate(
  label: label | selector | location | function
) -> location
```

=== `selector`: label | selector | location | function (Required, Positional)

A selector that should match exactly one element. This element will be located.

Especially useful in combination with

- #link("/docs/reference/introspection/here/")[here] to locate the current context,
- a #link("/docs/reference/introspection/location/")[location] retrieved from some queried element via the #link("/docs/reference/foundations/content/#definitions-location")[location()] method on content.
= location

Identifies an element in the document.

A location uniquely identifies an element in the document and lets you access its absolute position on the pages. You can retrieve the current location with the #link("/docs/reference/introspection/here/")[here] function and the location of a queried or shown element with the #link("/docs/reference/foundations/content/#definitions-location")[location()] method on content.

== Locatable elements

Currently, only a subset of element functions is locatable. Aside from headings and figures, this includes equations, references, quotes and all elements with an explicit label. As a result, you _can_ query for e.g. #link("/docs/reference/model/strong/")[strong] elements, but you will find only those that have an explicit label attached to them. This limitation will be resolved in the future.

== Definitions

=== `page`

Returns the page number for this location.

Note that this does not return the value of the #link("/docs/reference/introspection/counter/")[page counter] at this location, but the true page number (starting from one).

If you want to know the value of the page counter, use `counter(page).at(loc)` instead.

Can be used with #link("/docs/reference/introspection/here/")[here] to retrieve the physical page position of the current context:

```
page(
  
) -> int
```

```typst
#context [
  I am located on
  page #here().page()
]
```

=== `position`

Returns a dictionary with the page number and the x, y position for this location. The page number starts at one and the coordinates are measured from the top-left of the page.

If you only need the page number, use `page()` instead as it allows Typst to skip unnecessary work.

```
position(
  
) -> dictionary
```

=== `page-numbering`

Returns the page numbering pattern of the page at this location. This can be used when displaying the page counter in order to obtain the local numbering. This is useful if you are building custom indices or outlines.

If the page numbering is set to `none` at that location, this function returns `none`.

```
page-numbering(
  
) -> function
```
= metadata

Exposes a value to the query system without producing visible content.

This element can be retrieved with the #link("/docs/reference/introspection/query/")[query] function and from the command line with #link("/docs/reference/introspection/query/#command-line-queries")[typst query]. Its purpose is to expose an arbitrary value to the introspection system. To identify a metadata value among others, you can attach a #link("/docs/reference/foundations/label/")[label] to it and query for that label.

The `metadata` element is especially useful for command line queries because it allows you to expose arbitrary values to the outside world.

```typst
// Put metadata somewhere.
#metadata("This is a note") <note>

// And find it from anywhere else.
#context {
  query(<note>).first().value
}
```

== Parameters

```
metadata(
  any
) -> content
```

=== `value`: any (Required, Positional)

The value to embed into the document.
= query

Finds elements in the document.

The `query` functions lets you search your document for elements of a particular type or with a particular label. To use it, you first need to ensure that #link("/docs/reference/context/")[context] is available.

== Finding elements

In the example below, we manually create a table of contents instead of using the #link("/docs/reference/model/outline/")[outline] function.

To do this, we first query for all headings in the document at level 1 and where `outlined` is true. Querying only for headings at level 1 ensures that, for the purpose of this example, sub-headings are not included in the table of contents. The `outlined` field is used to exclude the "Table of Contents" heading itself.

Note that we open a `context` to be able to use the `query` function.

```typst
#set page(numbering: "1")

#heading(outlined: false)[
  Table of Contents
]
#context {
  let chapters = query(
    heading.where(
      level: 1,
      outlined: true,
    )
  )
  for chapter in chapters {
    let loc = chapter.location()
    let nr = numbering(
      loc.page-numbering(),
      ..counter(page).at(loc),
    )
    [#chapter.body #h(1fr) #nr \ ]
  }
}

= Introduction
#lorem(10)
#pagebreak()

== Sub-Heading
#lorem(8)

= Discussion
#lorem(18)
```

To get the page numbers, we first get the location of the elements returned by `query` with #link("/docs/reference/foundations/content/#definitions-location")[location]. We then also retrieve the #link("/docs/reference/introspection/location/#definitions-page-numbering")[page numbering] and #link("/docs/reference/introspection/counter/#page-counter")[page counter] at that location and apply the numbering to the counter.

== A word of caution

To resolve all your queries, Typst evaluates and layouts parts of the document multiple times. However, there is no guarantee that your queries can actually be completely resolved. If you aren't careful a query can affect itself—leading to a result that never stabilizes.

In the example below, we query for all headings in the document. We then generate as many headings. In the beginning, there's just one heading, titled `Real`. Thus, `count` is `1` and one `Fake` heading is generated. Typst sees that the query's result has changed and processes it again. This time, `count` is `2` and two `Fake` headings are generated. This goes on and on. As we can see, the output has a finite amount of headings. This is because Typst simply gives up after a few attempts.

In general, you should try not to write queries that affect themselves. The same words of caution also apply to other introspection features like #link("/docs/reference/introspection/counter/")[counters] and #link("/docs/reference/introspection/state/")[state].

```typst
= Real
#context {
  let elems = query(heading)
  let count = elems.len()
  count * [= Fake]
}
```

== Command line queries

You can also perform queries from the command line with the `typst query` command. This command executes an arbitrary query on the document and returns the resulting elements in serialized form. Consider the following `example.typ` file which contains some invisible #link("/docs/reference/introspection/metadata/")[metadata]:

You can execute a query on it as follows using Typst's CLI:

Frequently, you're interested in only one specific field of the resulting elements. In the case of the `metadata` element, the `value` field is the interesting one. You can extract just this field with the `--field` argument.

If you are interested in just a single element, you can use the `--one` flag to extract just it.

== Parameters

```
query(
  label: label | selector | location | function
) -> array
```

=== `target`: label | selector | location | function (Required, Positional)

Can be

- an element function like a `heading` or `figure`,
- a `<label>`,
- a more complex selector like `heading.where(level: 1)`,
- or `selector(heading).before(here())`.

Only #link("/docs/reference/introspection/location/#locatable")[locatable] element functions are supported.
= state

Manages stateful parts of your document.

Let's say you have some computations in your document and want to remember the result of your last computation to use it in the next one. You might try something similar to the code below and expect it to output 10, 13, 26, and 21. However this *does not work* in Typst. If you test this code, you will see that Typst complains with the following error message: _Variables from outside the function are read-only and cannot be modified._

== State and document markup

Why does it do that? Because, in general, this kind of computation with side effects is problematic in document markup and Typst is upfront about that. For the results to make sense, the computation must proceed in the same order in which the results will be laid out in the document. In our simple example, that's the case, but in general it might not be.

Let's look at a slightly different, but similar kind of state: The heading numbering. We want to increase the heading counter at each heading. Easy enough, right? Just add one. Well, it's not that simple. Consider the following example:

```typst
#set heading(numbering: "1.")
#let template(body) = [
  = Outline
  ...
  #body
]

#show: template

= Introduction
...
```

Here, Typst first processes the body of the document after the show rule, sees the `Introduction` heading, then passes the resulting content to the `template` function and only then sees the `Outline`. Just counting up would number the `Introduction` with `1` and the `Outline` with `2`.

== Managing state in Typst

So what do we do instead? We use Typst's state management system. Calling the `state` function with an identifying string key and an optional initial value gives you a state value which exposes a few functions. The two most important ones are `get` and `update`:

- The get function retrieves the current value of the state. Because the value can vary over the course of the document, it is a contextual function that can only be used when context is available.
- The update function modifies the state. You can give it any value. If given a non-function value, it sets the state to that value. If given a function, that function receives the previous state and has to return the new state.

Our initial example would now look like this:

```typst
#let s = state("x", 0)
#let compute(expr) = [
  #s.update(x =>
    eval(expr.replace("x", str(x)))
  )
  New value is #context s.get().
]

#compute("10") \
#compute("x + 3") \
#compute("x * 2") \
#compute("x - 5")
```

State managed by Typst is always updated in layout order, not in evaluation order. The `update` method returns content and its effect occurs at the position where the returned content is inserted into the document.

As a result, we can now also store some of the computations in variables, but they still show the correct results:

```typst
...

#let more = [
  #compute("x * 2") \
  #compute("x - 5")
]

#compute("10") \
#compute("x + 3") \
#more
```

This example is of course a bit silly, but in practice this is often exactly what you want! A good example are heading counters, which is why Typst's #link("/docs/reference/introspection/counter/")[counting system] is very similar to its state system.

== Time Travel

By using Typst's state management system you also get time travel capabilities! We can find out what the value of the state will be at any position in the document from anywhere else. In particular, the `at` method gives us the value of the state at any particular location and the `final` methods gives us the value of the state at the end of the document.

```typst
...

Value at `<here>` is
#context s.at(<here>)

#compute("10") \
#compute("x + 3") \
*Here.* <here> \
#compute("x * 2") \
#compute("x - 5")
```

== A word of caution

To resolve the values of all states, Typst evaluates parts of your code multiple times. However, there is no guarantee that your state manipulation can actually be completely resolved.

For instance, if you generate state updates depending on the final value of a state, the results might never converge. The example below illustrates this. We initialize our state with `1` and then update it to its own final value plus 1. So it should be `2`, but then its final value is `2`, so it should be `3`, and so on. This example displays a finite value because Typst simply gives up after a few attempts.

```typst
// This is bad!
#let s = state("x", 1)
#context s.update(s.final() + 1)
#context s.get()
```

In general, you should try not to generate state updates from within context expressions. If possible, try to express your updates as non-contextual values or functions that compute the new value from the previous value. Sometimes, it cannot be helped, but in those cases it is up to you to ensure that the result converges.

== Constructor

Create a new state identified by a key.

```
state(
  str: str,
  any
) -> state
```

==== `key`: str (Required, Positional)

The key that identifies this state.

==== `init`: any (Positional)

The initial value of the state.

Default: `none`

== Definitions

=== `get`

Retrieves the value of the state at the current location.

This is equivalent to `state.at(here())`.

```
get(
  
) -> 
```

=== `at`

Retrieves the value of the state at the given selector's unique match.

The `selector` must match exactly one element in the document. The most useful kinds of selectors for this are #link("/docs/reference/foundations/label/")[labels] and #link("/docs/reference/introspection/location/")[locations].

```
at(
  label: label | selector | location | function
) -> function
```

==== `selector`: label | selector | location | function (Required, Positional)

The place at which the state's value should be retrieved.

=== `final`

Retrieves the value of the state at the end of the document.

```
final(
  
) -> 
```

=== `update`

Update the value of the state.

The update will be in effect at the position where the returned content is inserted into the document. If you don't put the output into the document, nothing happens! This would be the case, for example, if you write `let _ = state("key").update(7)`. State updates are always applied in layout order and in that case, Typst wouldn't know when to update the state.

```
update(
  function: any | function
) -> content
```

==== `update`: any | function (Required, Positional)

If given a non function-value, sets the state to that value. If given a function, that function receives the previous state and has to return the new state.
= align

Aligns content horizontally and vertically.

== Example

Let's start with centering our content horizontally:

```typst
#set page(height: 120pt)
#set align(center)

Centered text, a sight to see \
In perfect balance, visually \
Not left nor right, it stands alone \
A work of art, a visual throne
```

To center something vertically, use _horizon_ alignment:

```typst
#set page(height: 120pt)
#set align(horizon)

Vertically centered, \
the stage had entered, \
a new paragraph.
```

== Combining alignments

You can combine two alignments with the `+` operator. Let's also only apply this to one piece of content by using the function form instead of a set rule:

```typst
#set page(height: 120pt)
Though left in the beginning ...

#align(right + bottom)[
  ... they were right in the end, \
  and with addition had gotten, \
  the paragraph to the bottom!
]
```

== Nested alignment

You can use varying alignments for layout containers and the elements within them. This way, you can create intricate layouts:

```typst
#align(center, block[
  #set align(left)
  Though centered together \
  alone \
  we \
  are \
  left.
])
```

== Alignment within the same line

The `align` function performs block-level alignment and thus always interrupts the current paragraph. To have different alignment for parts of the same line, you should use #link("/docs/reference/layout/h/")[fractional spacing] instead:

```typst
Start #h(1fr) End
```

== Parameters

```
align(
  alignment: alignment,
  content: content
) -> content
```

=== `alignment`: alignment (Positional, Settable)

The #link("/docs/reference/layout/alignment/")[alignment] along both axes.

Default: `start + top`

*Example:*
```typst
#set page(height: 6cm)
#set text(lang: "ar")

مثال
#align(
  end + horizon,
  rect(inset: 12pt)[ركن]
)
```

=== `body`: content (Required, Positional)

The content to align.
= alignment

Where to #link("/docs/reference/layout/align/")[align] something along an axis.

Possible values are:

- `start`: Aligns at the #link("/docs/reference/layout/direction/#definitions-start")[start] of the #link("/docs/reference/text/text/#parameters-dir")[text direction].
- `end`: Aligns at the #link("/docs/reference/layout/direction/#definitions-end")[end] of the #link("/docs/reference/text/text/#parameters-dir")[text direction].
- `left`: Align at the left.
- `center`: Aligns in the middle, horizontally.
- `right`: Aligns at the right.
- `top`: Aligns at the top.
- `horizon`: Aligns in the middle, vertically.
- `bottom`: Align at the bottom.

These values are available globally and also in the alignment type's scope, so you can write either of the following two:

```typst
#align(center)[Hi]
#align(alignment.center)[Hi]
```

== 2D alignments

To align along both axes at the same time, add the two alignments using the `+` operator. For example, `top + right` aligns the content to the top right corner.

```typst
#set page(height: 3cm)
#align(center + bottom)[Hi]
```

== Fields

The `x` and `y` fields hold the alignment's horizontal and vertical components, respectively (as yet another `alignment`). They may be `none`.

```typst
#(top + right).x \
#left.x \
#left.y (none)
```

== Definitions

=== `axis`

The axis this alignment belongs to.

- `"horizontal"` for `start`, `left`, `center`, `right`, and `end`
- `"vertical"` for `top`, `horizon`, and `bottom`
- `none` for 2-dimensional alignments

```
axis(
  
) -> str
```

```typst
#left.axis() \
#bottom.axis()
```

=== `inv`

The inverse alignment.

```
inv(
  
) -> alignment
```

```typst
#top.inv() \
#left.inv() \
#center.inv() \
#(left + bottom).inv()
```
= angle

An angle describing a rotation.

Typst supports the following angular units:

- Degrees: `180deg`
- Radians: `3.14rad`

== Example

```typst
#rotate(10deg)[Hello there!]
```

== Definitions

=== `rad`

Converts this angle to radians.

```
rad(
  
) -> float
```

=== `deg`

Converts this angle to degrees.

```
deg(
  
) -> float
```
= block

A block-level container.

Such a container can be used to separate content, size it, and give it a background or border.

Blocks are also the primary way to control whether text becomes part of a paragraph or not. See #link("/docs/reference/model/par/#what-becomes-a-paragraph")[the paragraph documentation] for more details.

== Examples

With a block, you can give a background to content while still allowing it to break across multiple pages.

```typst
#set page(height: 100pt)
#block(
  fill: luma(230),
  inset: 8pt,
  radius: 4pt,
  lorem(30),
)
```

Blocks are also useful to force elements that would otherwise be inline to become block-level, especially when writing show rules.

```typst
#show heading: it => it.body
= Blockless
More text.

#show heading: it => block(it.body)
= Blocky
More text.
```

== Parameters

```
block(
  width: auto | relative,
  height: auto | relative | fraction,
  breakable: bool,
  fill: none | color | gradient | tiling,
  stroke: none | length | color | gradient | stroke | tiling | dictionary,
  radius: relative | dictionary,
  inset: relative | dictionary,
  outset: relative | dictionary,
  spacing: relative | fraction,
  above: auto | relative | fraction,
  below: auto | relative | fraction,
  clip: bool,
  sticky: bool,
  body: none | content
) -> content
```

=== `width`: auto | relative (Settable)

The block's width.

Default: `auto`

*Example:*
```typst
#set align(center)
#block(
  width: 60%,
  inset: 8pt,
  fill: silver,
  lorem(10),
)
```

=== `height`: auto | relative | fraction (Settable)

The block's height. When the height is larger than the remaining space on a page and #link("/docs/reference/layout/block/#parameters-breakable")[breakable] is `true`, the block will continue on the next page with the remaining height.

Default: `auto`

*Example:*
```typst
#set page(height: 80pt)
#set align(center)
#block(
  width: 80%,
  height: 150%,
  fill: aqua,
)
```

=== `breakable`: bool (Settable)

Whether the block can be broken and continue on the next page.

Default: `true`

*Example:*
```typst
#set page(height: 80pt)
The following block will
jump to its own page.
#block(
  breakable: false,
  lorem(15),
)
```

=== `fill`: none | color | gradient | tiling (Settable)

The block's background color. See the #link("/docs/reference/visualize/rect/#parameters-fill")[rectangle's documentation] for more details.

Default: `none`

=== `stroke`: none | length | color | gradient | stroke | tiling | dictionary (Settable)

The block's border color. See the #link("/docs/reference/visualize/rect/#parameters-stroke")[rectangle's documentation] for more details.

Default: `(:)`

=== `radius`: relative | dictionary (Settable)

How much to round the block's corners. See the #link("/docs/reference/visualize/rect/#parameters-radius")[rectangle's documentation] for more details.

Default: `(:)`

=== `inset`: relative | dictionary (Settable)

How much to pad the block's content. See the #link("/docs/reference/layout/box/#parameters-inset")[box's documentation] for more details.

Default: `(:)`

=== `outset`: relative | dictionary (Settable)

How much to expand the block's size without affecting the layout. See the #link("/docs/reference/layout/box/#parameters-outset")[box's documentation] for more details.

Default: `(:)`

=== `spacing`: relative | fraction (Settable)

The spacing around the block. When `auto`, inherits the paragraph #link("/docs/reference/model/par/#parameters-spacing")[spacing].

For two adjacent blocks, the larger of the first block's `above` and the second block's `below` spacing wins. Moreover, block spacing takes precedence over paragraph #link("/docs/reference/model/par/#parameters-spacing")[spacing].

Note that this is only a shorthand to set `above` and `below` to the same value. Since the values for `above` and `below` might differ, a #link("/docs/reference/context/")[context] block only provides access to `block.above` and `block.below`, not to `block.spacing` directly.

This property can be used in combination with a show rule to adjust the spacing around arbitrary block-level elements.

Default: `1.2em`

*Example:*
```typst
#set align(center)
#show math.equation: set block(above: 8pt, below: 16pt)

This sum of $x$ and $y$:
$ x + y = z $
A second paragraph.
```

=== `above`: auto | relative | fraction (Settable)

The spacing between this block and its predecessor.

Default: `auto`

=== `below`: auto | relative | fraction (Settable)

The spacing between this block and its successor.

Default: `auto`

=== `clip`: bool (Settable)

Whether to clip the content inside the block.

Clipping is useful when the block's content is larger than the block itself, as any content that exceeds the block's bounds will be hidden.

Default: `false`

*Example:*
```typst
#block(
  width: 50pt,
  height: 50pt,
  clip: true,
  image("tiger.jpg", width: 100pt, height: 100pt)
)
```

=== `sticky`: bool (Settable)

Whether this block must stick to the following one, with no break in between.

This is, by default, set on heading blocks to prevent orphaned headings at the bottom of the page.

Default: `false`

*Example:*
```typst
// Disable stickiness of headings.
#show heading: set block(sticky: false)
#lorem(20)

= Chapter
#lorem(10)
```

=== `body`: none | content (Positional, Settable)

The contents of the block.

Default: `none`
= box

An inline-level container that sizes content.

All elements except inline math, text, and boxes are block-level and cannot occur inside of a #link("/docs/reference/model/par/")[paragraph]. The box function can be used to integrate such elements into a paragraph. Boxes take the size of their contents by default but can also be sized explicitly.

== Example

```typst
Refer to the docs
#box(
  height: 9pt,
  image("docs.svg")
)
for more information.
```

== Parameters

```
box(
  width: auto | relative | fraction,
  height: auto | relative,
  baseline: relative,
  fill: none | color | gradient | tiling,
  stroke: none | length | color | gradient | stroke | tiling | dictionary,
  radius: relative | dictionary,
  inset: relative | dictionary,
  outset: relative | dictionary,
  clip: bool,
  body: none | content
) -> content
```

=== `width`: auto | relative | fraction (Settable)

The width of the box.

Boxes can have #link("/docs/reference/layout/fraction/")[fractional] widths, as the example below demonstrates.

_Note:_ Currently, only boxes and only their widths might be fractionally sized within paragraphs. Support for fractionally sized images, shapes, and more might be added in the future.

Default: `auto`

*Example:*
```typst
Line in #box(width: 1fr, line(length: 100%)) between.
```

=== `height`: auto | relative (Settable)

The height of the box.

Default: `auto`

=== `baseline`: relative (Settable)

An amount to shift the box's baseline by.

Default: `0% + 0pt`

*Example:*
```typst
Image: #box(baseline: 40%, image("tiger.jpg", width: 2cm)).
```

=== `fill`: none | color | gradient | tiling (Settable)

The box's background color. See the #link("/docs/reference/visualize/rect/#parameters-fill")[rectangle's documentation] for more details.

Default: `none`

=== `stroke`: none | length | color | gradient | stroke | tiling | dictionary (Settable)

The box's border color. See the #link("/docs/reference/visualize/rect/#parameters-stroke")[rectangle's documentation] for more details.

Default: `(:)`

=== `radius`: relative | dictionary (Settable)

How much to round the box's corners. See the #link("/docs/reference/visualize/rect/#parameters-radius")[rectangle's documentation] for more details.

Default: `(:)`

=== `inset`: relative | dictionary (Settable)

How much to pad the box's content.

_Note:_ When the box contains text, its exact size depends on the current #link("/docs/reference/text/text/#parameters-top-edge")[text edges].

Default: `(:)`

*Example:*
```typst
#rect(inset: 0pt)[Tight]
```

=== `outset`: relative | dictionary (Settable)

How much to expand the box's size without affecting the layout.

This is useful to prevent padding from affecting line layout. For a generalized version of the example below, see the documentation for the #link("/docs/reference/text/raw/#parameters-block")[raw text's block parameter].

Default: `(:)`

*Example:*
```typst
An inline
#box(
  fill: luma(235),
  inset: (x: 3pt, y: 0pt),
  outset: (y: 3pt),
  radius: 2pt,
)[rectangle].
```

=== `clip`: bool (Settable)

Whether to clip the content inside the box.

Clipping is useful when the box's content is larger than the box itself, as any content that exceeds the box's bounds will be hidden.

Default: `false`

*Example:*
```typst
#box(
  width: 50pt,
  height: 50pt,
  clip: true,
  image("tiger.jpg", width: 100pt, height: 100pt)
)
```

=== `body`: none | content (Positional, Settable)

The contents of the box.

Default: `none`
= colbreak

Forces a column break.

The function will behave like a #link("/docs/reference/layout/pagebreak/")[page break] when used in a single column layout or the last column on a page. Otherwise, content after the column break will be placed in the next column.

== Example

```typst
#set page(columns: 2)
Preliminary findings from our
ongoing research project have
revealed a hitherto unknown
phenomenon of extraordinary
significance.

#colbreak()
Through rigorous experimentation
and analysis, we have discovered
a hitherto uncharacterized process
that defies our current
understanding of the fundamental
laws of nature.
```

== Parameters

```
colbreak(
  weak: bool
) -> content
```

=== `weak`: bool (Settable)

If `true`, the column break is skipped if the current column is already empty.

Default: `false`
= columns

Separates a region into multiple equally sized columns.

The `column` function lets you separate the interior of any container into multiple columns. It will currently not balance the height of the columns. Instead, the columns will take up the height of their container or the remaining height on the page. Support for balanced columns is planned for the future.

== Page-level columns

If you need to insert columns across your whole document, use the `page` function's #link("/docs/reference/layout/page/#parameters-columns")[columns parameter] instead. This will create the columns directly at the page-level rather than wrapping all of your content in a layout container. As a result, things like #link("/docs/reference/layout/pagebreak/")[pagebreaks], #link("/docs/reference/model/footnote/")[footnotes], and #link("/docs/reference/model/par/#definitions-line")[line numbers] will continue to work as expected. For more information, also read the #link("/docs/guides/page-setup-guide/#columns")[relevant part of the page setup guide].

== Breaking out of columns

To temporarily break out of columns (e.g. for a paper's title), use parent-scoped floating placement:

```typst
#set page(columns: 2, height: 150pt)

#place(
  top + center,
  scope: "parent",
  float: true,
  text(1.4em, weight: "bold")[
    My document
  ],
)

#lorem(40)
```

== Parameters

```
columns(
  count: int,
  gutter: relative,
  content: content
) -> content
```

=== `count`: int (Positional, Settable)

The number of columns.

Default: `2`

=== `gutter`: relative (Settable)

The size of the gutter space between each column.

Default: `4% + 0pt`

=== `body`: content (Required, Positional)

The content that should be layouted into the columns.
= direction

The four directions into which content can be laid out.

Possible values are:

- `ltr`: Left to right.
- `rtl`: Right to left.
- `ttb`: Top to bottom.
- `btt`: Bottom to top.

These values are available globally and also in the direction type's scope, so you can write either of the following two:

```typst
#stack(dir: rtl)[A][B][C]
#stack(dir: direction.rtl)[A][B][C]
```

== Definitions

=== `axis`

The axis this direction belongs to, either `"horizontal"` or `"vertical"`.

```
axis(
  
) -> str
```

```typst
#ltr.axis() \
#ttb.axis()
```

=== `start`

The start point of this direction, as an alignment.

```
start(
  
) -> alignment
```

```typst
#ltr.start() \
#rtl.start() \
#ttb.start() \
#btt.start()
```

=== `end`

The end point of this direction, as an alignment.

```
end(
  
) -> alignment
```

```typst
#ltr.end() \
#rtl.end() \
#ttb.end() \
#btt.end()
```

=== `inv`

The inverse direction.

```
inv(
  
) -> direction
```

```typst
#ltr.inv() \
#rtl.inv() \
#ttb.inv() \
#btt.inv()
```
= fraction

Defines how the remaining space in a layout is distributed.

Each fractionally sized element gets space based on the ratio of its fraction to the sum of all fractions.

For more details, also see the #link("/docs/reference/layout/h/")[h] and #link("/docs/reference/layout/v/")[v] functions and the #link("/docs/reference/layout/grid/")[grid function].

== Example

```typst
Left #h(1fr) Left-ish #h(2fr) Right
```
= grid

Arranges content in a grid.

The grid element allows you to arrange content in a grid. You can define the number of rows and columns, as well as the size of the gutters between them. There are multiple sizing modes for columns and rows that can be used to create complex layouts.

While the grid and table elements work very similarly, they are intended for different use cases and carry different semantics. The grid element is intended for presentational and layout purposes, while the #link("/docs/reference/model/table/")[table] element is intended for, in broad terms, presenting multiple related data points. In the future, Typst will annotate its output such that screenreaders will announce content in `table` as tabular while a grid's content will be announced no different than multiple content blocks in the document flow. Set and show rules on one of these elements do not affect the other.

A grid's sizing is determined by the track sizes specified in the arguments. Because each of the sizing parameters accepts the same values, we will explain them just once, here. Each sizing argument accepts an array of individual track sizes. A track size is either:

- auto: The track will be sized to fit its contents. It will be at most as large as the remaining space. If there is more than one auto track width, and together they claim more than the available space, the auto tracks will fairly distribute the available space among themselves.
- A fixed or relative length (e.g. 10pt or 20% - 1cm): The track will be exactly of this size.
- A fractional length (e.g. 1fr): Once all other tracks have been sized, the remaining space will be divided among the fractional tracks according to their fractions. For example, if there are two fractional tracks, each with a fraction of 1fr, they will each take up half of the remaining space.

To specify a single track, the array can be omitted in favor of a single value. To specify multiple `auto` tracks, enter the number of tracks instead of an array. For example, `columns:` `3` is equivalent to `columns:` `(auto, auto, auto)`.

== Examples

The example below demonstrates the different track sizing options. It also shows how you can use #link("/docs/reference/layout/grid/#definitions-cell")[grid.cell] to make an individual cell span two grid tracks.

```typst
// We use `rect` to emphasize the
// area of cells.
#set rect(
  inset: 8pt,
  fill: rgb("e4e5ea"),
  width: 100%,
)

#grid(
  columns: (60pt, 1fr, 2fr),
  rows: (auto, 60pt),
  gutter: 3pt,
  rect[Fixed width, auto height],
  rect[1/3 of the remains],
  rect[2/3 of the remains],
  rect(height: 100%)[Fixed height],
  grid.cell(
    colspan: 2,
    image("tiger.jpg", width: 100%),
  ),
)
```

You can also #link("/docs/reference/foundations/arguments/#spreading")[spread] an array of strings or content into a grid to populate its cells.

```typst
#grid(
  columns: 5,
  gutter: 5pt,
  ..range(25).map(str)
)
```

== Styling the grid

The grid's appearance can be customized through different parameters. These are the most important ones:

- #link("/docs/reference/layout/grid/#parameters-fill")[fill] to give all cells a background
- #link("/docs/reference/layout/grid/#parameters-align")[align] to change how cells are aligned
- #link("/docs/reference/layout/grid/#parameters-inset")[inset] to optionally add internal padding to each cell
- #link("/docs/reference/layout/grid/#parameters-stroke")[stroke] to optionally enable grid lines with a certain stroke

If you need to override one of the above options for a single cell, you can use the #link("/docs/reference/layout/grid/#definitions-cell")[grid.cell] element. Likewise, you can override individual grid lines with the #link("/docs/reference/layout/grid/#definitions-hline")[grid.hline] and #link("/docs/reference/layout/grid/#definitions-vline")[grid.vline] elements.

Alternatively, if you need the appearance options to depend on a cell's position (column and row), you may specify a function to `fill` or `align` of the form `(column, row) => value`. You may also use a show rule on #link("/docs/reference/layout/grid/#definitions-cell")[grid.cell] - see that element's examples or the examples below for more information.

Locating most of your styling in set and show rules is recommended, as it keeps the grid's or table's actual usages clean and easy to read. It also allows you to easily change the grid's appearance in one place.

There are three ways to set the stroke of a grid cell: through #link("/docs/reference/layout/grid/#definitions-cell-stroke")[grid.cell's stroke field], by using #link("/docs/reference/layout/grid/#definitions-hline")[grid.hline] and #link("/docs/reference/layout/grid/#definitions-vline")[grid.vline], or by setting the #link("/docs/reference/layout/grid/#parameters-stroke")[grid's stroke field]. When multiple of these settings are present and conflict, the `hline` and `vline` settings take the highest precedence, followed by the `cell` settings, and finally the `grid` settings.

Furthermore, strokes of a repeated grid header or footer will take precedence over regular cell strokes.

== Parameters

```
grid(
  columns: auto | int | relative | fraction | array,
  rows: auto | int | relative | fraction | array,
  gutter: auto | int | relative | fraction | array,
  column-gutter: auto | int | relative | fraction | array,
  row-gutter: auto | int | relative | fraction | array,
  fill: none | color | gradient | array | tiling | function,
  align: auto | array | alignment | function,
  stroke: none | length | color | gradient | array | stroke | tiling | dictionary | function,
  inset: relative | array | dictionary | function,
  ..: content
) -> content
```

=== `columns`: auto | int | relative | fraction | array (Settable)

The column sizes.

Either specify a track size array or provide an integer to create a grid with that many `auto`-sized columns. Note that opposed to rows and gutters, providing a single track size will only ever create a single column.

Default: `()`

=== `rows`: auto | int | relative | fraction | array (Settable)

The row sizes.

If there are more cells than fit the defined rows, the last row is repeated until there are no more cells.

Default: `()`

=== `gutter`: auto | int | relative | fraction | array (Settable)

The gaps between rows and columns.

If there are more gutters than defined sizes, the last gutter is repeated.

This is a shorthand to set `column-gutter` and `row-gutter` to the same value.

Default: `()`

=== `column-gutter`: auto | int | relative | fraction | array (Settable)

The gaps between columns.

Default: `()`

=== `row-gutter`: auto | int | relative | fraction | array (Settable)

The gaps between rows.

Default: `()`

=== `fill`: none | color | gradient | array | tiling | function (Settable)

How to fill the cells.

This can be a color or a function that returns a color. The function receives the cells' column and row indices, starting from zero. This can be used to implement striped grids.

Default: `none`

*Example:*
```typst
#grid(
  fill: (x, y) =>
    if calc.even(x + y) { luma(230) }
    else { white },
  align: center + horizon,
  columns: 4,
  inset: 2pt,
  [X], [O], [X], [O],
  [O], [X], [O], [X],
  [X], [O], [X], [O],
  [O], [X], [O], [X],
)
```

=== `align`: auto | array | alignment | function (Settable)

How to align the cells' content.

This can either be a single alignment, an array of alignments (corresponding to each column) or a function that returns an alignment. The function receives the cells' column and row indices, starting from zero. If set to `auto`, the outer alignment is used.

You can find an example for this argument at the #link("/docs/reference/model/table/#parameters-align")[table.align] parameter.

Default: `auto`

=== `stroke`: none | length | color | gradient | array | stroke | tiling | dictionary | function (Settable)

How to #link("/docs/reference/visualize/stroke/")[stroke] the cells.

Grids have no strokes by default, which can be changed by setting this option to the desired stroke.

If it is necessary to place lines which can cross spacing between cells produced by the `gutter` option, or to override the stroke between multiple specific cells, consider specifying one or more of #link("/docs/reference/layout/grid/#definitions-hline")[grid.hline] and #link("/docs/reference/layout/grid/#definitions-vline")[grid.vline] alongside your grid cells.

Default: `(:)`

*Example:*
```typst
#set page(height: 13em, width: 26em)

#let cv(..jobs) = grid(
  columns: 2,
  inset: 5pt,
  stroke: (x, y) => if x == 0 and y > 0 {
    (right: (
      paint: luma(180),
      thickness: 1.5pt,
      dash: "dotted"
    ))
  },
  grid.header(grid.cell(colspan: 2)[
    *Professional Experience*
    #box(width: 1fr, line(length: 100%, stroke: luma(180)))
  ]),
  ..{
    let last = none
    for job in jobs.pos() {
      (
        if job.year != last [*#job.year*],
        [
          *#job.company* - #job.role _(#job.timeframe)_ \
          #job.details
        ]
      )
      last = job.year
    }
  }
)

#cv(
  (
    year: 2012,
    company: [Pear Seed & Co.],
    role: [Lead Engineer],
    timeframe: [Jul - Dec],
    details: [
      - Raised engineers from 3x to 10x
      - Did a great job
    ],
  ),
  (
    year: 2012,
    company: [Mega Corp.],
    role: [VP of Sales],
    timeframe: [Mar - Jun],
    details: [- Closed tons of customers],
  ),
  (
    year: 2013,
    company: [Tiny Co.],
    role: [CEO],
    timeframe: [Jan - Dec],
    details: [- Delivered 4x more shareholder value],
  ),
  (
    year: 2014,
    company: [Glorbocorp Ltd],
    role: [CTO],
    timeframe: [Jan - Mar],
    details: [- Drove containerization forward],
  ),
)
```

=== `inset`: relative | array | dictionary | function (Settable)

How much to pad the cells' content.

You can find an example for this argument at the #link("/docs/reference/model/table/#parameters-inset")[table.inset] parameter.

Default: `(:)`

=== `children`: content (Required, Positional, Variadic)

The contents of the grid cells, plus any extra grid lines specified with the #link("/docs/reference/layout/grid/#definitions-hline")[grid.hline] and #link("/docs/reference/layout/grid/#definitions-vline")[grid.vline] elements.

The cells are populated in row-major order.

== Definitions

=== `cell`

A cell in the grid. You can use this function in the argument list of a grid to override grid style properties for an individual cell or manually positioning it within the grid. You can also use this function in show rules to apply certain styles to multiple cells at once.

For example, you can override the position and stroke for a single cell:

```
cell(
  content: content,
  x: auto | int,
  y: auto | int,
  colspan: int,
  rowspan: int,
  fill: none | auto | color | gradient | tiling,
  align: auto | alignment,
  inset: auto | relative | dictionary,
  stroke: none | length | color | gradient | stroke | tiling | dictionary,
  breakable: auto | bool
) -> content
```

```typst
#set text(15pt, font: "Noto Sans Symbols 2")
#show regex("[♚-♟︎]"): set text(fill: rgb("21212A"))
#show regex("[♔-♙]"): set text(fill: rgb("111015"))

#grid(
  fill: (x, y) => rgb(
    if calc.odd(x + y) { "7F8396" }
    else { "EFF0F3" }
  ),
  columns: (1em,) * 8,
  rows: 1em,
  align: center + horizon,

  [♖], [♘], [♗], [♕], [♔], [♗], [♘], [♖],
  [♙], [♙], [♙], [♙], [],  [♙], [♙], [♙],
  grid.cell(
    x: 4, y: 3,
    stroke: blue.transparentize(60%)
  )[♙],

  ..(grid.cell(y: 6)[♟],) * 8,
  ..([♜], [♞], [♝], [♛], [♚], [♝], [♞], [♜])
    .map(grid.cell.with(y: 7)),
)
```

You may also apply a show rule on `grid.cell` to style all cells at once, which allows you, for example, to apply styles based on a cell's position. Refer to the examples of the #link("/docs/reference/model/table/#definitions-cell")[table.cell] element to learn more about this.

==== `body`: content (Required, Positional)

The cell's body.

==== `x`: auto | int (Settable)

The cell's column (zero-indexed). This field may be used in show rules to style a cell depending on its column.

You may override this field to pick in which column the cell must be placed. If no row (`y`) is chosen, the cell will be placed in the first row (starting at row 0) with that column available (or a new row if none). If both `x` and `y` are chosen, however, the cell will be placed in that exact position. An error is raised if that position is not available (thus, it is usually wise to specify cells with a custom position before cells with automatic positions).

Default: `auto`

*Example:*
```typst
#let circ(c) = circle(
    fill: c, width: 5mm
)

#grid(
  columns: 4,
  rows: 7mm,
  stroke: .5pt + blue,
  align: center + horizon,
  inset: 1mm,

  grid.cell(x: 2, y: 2, circ(aqua)),
  circ(yellow),
  grid.cell(x: 3, circ(green)),
  circ(black),
)
```

==== `y`: auto | int (Settable)

The cell's row (zero-indexed). This field may be used in show rules to style a cell depending on its row.

You may override this field to pick in which row the cell must be placed. If no column (`x`) is chosen, the cell will be placed in the first column (starting at column 0) available in the chosen row. If all columns in the chosen row are already occupied, an error is raised.

Default: `auto`

*Example:*
```typst
#let tri(c) = polygon.regular(
  fill: c,
  size: 5mm,
  vertices: 3,
)

#grid(
  columns: 2,
  stroke: blue,
  inset: 1mm,

  tri(black),
  grid.cell(y: 1, tri(teal)),
  grid.cell(y: 1, tri(red)),
  grid.cell(y: 2, tri(orange))
)
```

==== `colspan`: int (Settable)

The amount of columns spanned by this cell.

Default: `1`

==== `rowspan`: int (Settable)

The amount of rows spanned by this cell.

Default: `1`

==== `fill`: none | auto | color | gradient | tiling (Settable)

The cell's #link("/docs/reference/layout/grid/#parameters-fill")[fill] override.

Default: `auto`

==== `align`: auto | alignment (Settable)

The cell's #link("/docs/reference/layout/grid/#parameters-align")[alignment] override.

Default: `auto`

==== `inset`: auto | relative | dictionary (Settable)

The cell's #link("/docs/reference/layout/grid/#parameters-inset")[inset] override.

Default: `auto`

==== `stroke`: none | length | color | gradient | stroke | tiling | dictionary (Settable)

The cell's #link("/docs/reference/layout/grid/#parameters-stroke")[stroke] override.

Default: `(:)`

==== `breakable`: auto | bool (Settable)

Whether rows spanned by this cell can be placed in different pages. When equal to `auto`, a cell spanning only fixed-size rows is unbreakable, while a cell spanning at least one `auto`-sized row is breakable.

Default: `auto`

=== `hline`

A horizontal line in the grid.

Overrides any per-cell stroke, including stroke specified through the grid's `stroke` field. Can cross spacing between cells created through the grid's `column-gutter` option.

An example for this function can be found at the #link("/docs/reference/model/table/#definitions-hline")[table.hline] element.

```
hline(
  y: auto | int,
  start: int,
  end: none | int,
  stroke: none | length | color | gradient | stroke | tiling | dictionary,
  position: alignment
) -> content
```

==== `y`: auto | int (Settable)

The row above which the horizontal line is placed (zero-indexed). If the `position` field is set to `bottom`, the line is placed below the row with the given index instead (see that field's docs for details).

Specifying `auto` causes the line to be placed at the row below the last automatically positioned cell (that is, cell without coordinate overrides) before the line among the grid's children. If there is no such cell before the line, it is placed at the top of the grid (row 0). Note that specifying for this option exactly the total amount of rows in the grid causes this horizontal line to override the bottom border of the grid, while a value of 0 overrides the top border.

Default: `auto`

==== `start`: int (Settable)

The column at which the horizontal line starts (zero-indexed, inclusive).

Default: `0`

==== `end`: none | int (Settable)

The column before which the horizontal line ends (zero-indexed, exclusive). Therefore, the horizontal line will be drawn up to and across column `end - 1`.

A value equal to `none` or to the amount of columns causes it to extend all the way towards the end of the grid.

Default: `none`

==== `stroke`: none | length | color | gradient | stroke | tiling | dictionary (Settable)

The line's stroke.

Specifying `none` removes any lines previously placed across this line's range, including hlines or per-cell stroke below it.

Default: `1pt + black`

==== `position`: alignment (Settable)

The position at which the line is placed, given its row (`y`) - either `top` to draw above it or `bottom` to draw below it.

This setting is only relevant when row gutter is enabled (and shouldn't be used otherwise - prefer just increasing the `y` field by one instead), since then the position below a row becomes different from the position above the next row due to the spacing between both.

Default: `top`

=== `vline`

A vertical line in the grid.

Overrides any per-cell stroke, including stroke specified through the grid's `stroke` field. Can cross spacing between cells created through the grid's `row-gutter` option.

```
vline(
  x: auto | int,
  start: int,
  end: none | int,
  stroke: none | length | color | gradient | stroke | tiling | dictionary,
  position: alignment
) -> content
```

==== `x`: auto | int (Settable)

The column before which the horizontal line is placed (zero-indexed). If the `position` field is set to `end`, the line is placed after the column with the given index instead (see that field's docs for details).

Specifying `auto` causes the line to be placed at the column after the last automatically positioned cell (that is, cell without coordinate overrides) before the line among the grid's children. If there is no such cell before the line, it is placed before the grid's first column (column 0). Note that specifying for this option exactly the total amount of columns in the grid causes this vertical line to override the end border of the grid (right in LTR, left in RTL), while a value of 0 overrides the start border (left in LTR, right in RTL).

Default: `auto`

==== `start`: int (Settable)

The row at which the vertical line starts (zero-indexed, inclusive).

Default: `0`

==== `end`: none | int (Settable)

The row on top of which the vertical line ends (zero-indexed, exclusive). Therefore, the vertical line will be drawn up to and across row `end - 1`.

A value equal to `none` or to the amount of rows causes it to extend all the way towards the bottom of the grid.

Default: `none`

==== `stroke`: none | length | color | gradient | stroke | tiling | dictionary (Settable)

The line's stroke.

Specifying `none` removes any lines previously placed across this line's range, including vlines or per-cell stroke below it.

Default: `1pt + black`

==== `position`: alignment (Settable)

The position at which the line is placed, given its column (`x`) - either `start` to draw before it or `end` to draw after it.

The values `left` and `right` are also accepted, but discouraged as they cause your grid to be inconsistent between left-to-right and right-to-left documents.

This setting is only relevant when column gutter is enabled (and shouldn't be used otherwise - prefer just increasing the `x` field by one instead), since then the position after a column becomes different from the position before the next column due to the spacing between both.

Default: `start`

=== `header`

A repeatable grid header.

If `repeat` is set to `true`, the header will be repeated across pages. For an example, refer to the #link("/docs/reference/model/table/#definitions-header")[table.header] element and the #link("/docs/reference/layout/grid/#parameters-stroke")[grid.stroke] parameter.

```
header(
  repeat: bool,
  ..: content
) -> content
```

==== `repeat`: bool (Settable)

Whether this header should be repeated across pages.

Default: `true`

==== `children`: content (Required, Positional, Variadic)

The cells and lines within the header.

=== `footer`

A repeatable grid footer.

Just like the #link("/docs/reference/layout/grid/#definitions-header")[grid.header] element, the footer can repeat itself on every page of the table.

No other grid cells may be placed after the footer.

```
footer(
  repeat: bool,
  ..: content
) -> content
```

==== `repeat`: bool (Settable)

Whether this footer should be repeated across pages.

Default: `true`

==== `children`: content (Required, Positional, Variadic)

The cells and lines within the footer.
= h

Inserts horizontal spacing into a paragraph.

The spacing can be absolute, relative, or fractional. In the last case, the remaining space on the line is distributed among all fractional spacings according to their relative fractions.

== Example

```typst
First #h(1cm) Second \
First #h(30%) Second
```

== Fractional spacing

With fractional spacing, you can align things within a line without forcing a paragraph break (like #link("/docs/reference/layout/align/")[align] would). Each fractionally sized element gets space based on the ratio of its fraction to the sum of all fractions.

```typst
First #h(1fr) Second \
First #h(1fr) Second #h(1fr) Third \
First #h(2fr) Second #h(1fr) Third
```

== Mathematical Spacing

In #link("/docs/reference/math/")[mathematical formulas], you can additionally use these constants to add spacing between elements: `thin` (1/6 em), `med` (2/9 em), `thick` (5/18 em), `quad` (1 em), `wide` (2 em).

== Parameters

```
h(
  relative: relative | fraction,
  weak: bool
) -> content
```

=== `amount`: relative | fraction (Required, Positional)

How much spacing to insert.

=== `weak`: bool (Settable)

If `true`, the spacing collapses at the start or end of a paragraph. Moreover, from multiple adjacent weak spacings all but the largest one collapse.

Weak spacing in markup also causes all adjacent markup spaces to be removed, regardless of the amount of spacing inserted. To force a space next to weak spacing, you can explicitly write `#" "` (for a normal space) or `~` (for a non-breaking space). The latter can be useful to create a construct that always attaches to the preceding word with one non-breaking space, independently of whether a markup space existed in front or not.

Default: `false`

*Example:*
```typst
#h(1cm, weak: true)
We identified a group of _weak_
specimens that fail to manifest
in most cases. However, when
#h(8pt, weak: true) supported
#h(8pt, weak: true) on both sides,
they do show up.

Further #h(0pt, weak: true) more,
even the smallest of them swallow
adjacent markup spaces.
```
